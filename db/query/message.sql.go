// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: message.sql

package query

import (
	"context"
)

const countMessagesForConversation = `-- name: CountMessagesForConversation :one
select count(*) 
from message
where conversation_id = ?
`

func (q *Queries) CountMessagesForConversation(ctx context.Context, conversationID int64) (int64, error) {
	row := q.queryRow(ctx, q.countMessagesForConversationStmt, countMessagesForConversation, conversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteMessagesForCurrentConversation = `-- name: DeleteMessagesForCurrentConversation :exec
;

delete from message
where id in (
	select m.id
	from message m
	join conversation c on m.conversation_id = c.id
	where c.selected = true
)
`

func (q *Queries) DeleteMessagesForCurrentConversation(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteMessagesForCurrentConversationStmt, deleteMessagesForCurrentConversation)
	return err
}

const getLatestMessages = `-- name: GetLatestMessages :many
select id, timestamp, role, content, conversation_id
from message
where id in (
	select m.id 
	from message m 
	join conversation c on m.conversation_id = c.id
	where c.selected = true
	order by m.id desc 
	limit ?
)
order by id
`

func (q *Queries) GetLatestMessages(ctx context.Context, limit int64) ([]Message, error) {
	rows, err := q.query(ctx, q.getLatestMessagesStmt, getLatestMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Role,
			&i.Content,
			&i.ConversationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessages = `-- name: GetMessages :many
SELECT id, timestamp, role, content, conversation_id FROM message
`

func (q *Queries) GetMessages(ctx context.Context) ([]Message, error) {
	rows, err := q.query(ctx, q.getMessagesStmt, getMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Role,
			&i.Content,
			&i.ConversationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviousMessageForRole = `-- name: GetPreviousMessageForRole :one
select m.id, m.timestamp, m.role, m.content, m.conversation_id
from message m
join conversation c on m.conversation_id = c.id
where m.role = ?
and c.selected = true
order by m.id desc
limit 1 offset ?
`

type GetPreviousMessageForRoleParams struct {
	Role   string `json:"role"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetPreviousMessageForRole(ctx context.Context, arg GetPreviousMessageForRoleParams) (Message, error) {
	row := q.queryRow(ctx, q.getPreviousMessageForRoleStmt, getPreviousMessageForRole, arg.Role, arg.Offset)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.Role,
		&i.Content,
		&i.ConversationID,
	)
	return i, err
}

const insertMessage = `-- name: InsertMessage :exec
;

INSERT INTO message (role, content, conversation_id) 
SELECT ?, ?, id
from conversation
where selected = true
`

type InsertMessageParams struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.exec(ctx, q.insertMessageStmt, insertMessage, arg.Role, arg.Content)
	return err
}
